<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapeador de Campos PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f9fafb;
            padding: 20px;
        }
        .mapper-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            max-width: 100%;
        }
        .pdf-viewer {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
        }
        .controls {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
        }
        canvas {
            width: 100%;
            cursor: crosshair;
            border: 1px solid #d1d5db;
        }
        .btn {
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            min-height: 44px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        .btn-primary {
            background: #009cb6;
            color: white;
        }
        .btn-primary:hover {
            background: #008299;
        }
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        .field-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .current-field {
            background: #f0f9fb;
            border: 2px solid #009cb6;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
        }
        .current-field h3 {
            color: #009cb6;
            font-size: 16px;
            margin-bottom: 5px;
        }
        .mapped-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 13px;
        }
        .mapped-item {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .page-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="mapper-container">
        <!-- PDF Viewer -->
        <div class="pdf-viewer">
            <div class="page-controls">
                <button class="btn btn-secondary" onclick="previousPage()">← Anterior</button>
                <span id="pageInfo">Página 1 / 2</span>
                <button class="btn btn-secondary" onclick="nextPage()">Seguinte →</button>
            </div>
            <canvas id="pdfCanvas"></canvas>
            <div style="text-align: center; margin-top: 10px; color: #6b7280; font-size: 12px;">
                <span id="canvasInfo">Carregando PDF...</span>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="current-field">
                <h3>Campo Atual</h3>
                <div id="currentFieldName" style="font-size: 18px; font-weight: bold; color: #1f2937;">
                    Escolhe um campo
                </div>
                <div style="margin-top: 10px;">
                    <span id="fieldProgress">0 / 62 campos</span>
                </div>
            </div>

            <select id="fieldSelector" class="field-selector" onchange="selectFieldManually()">
                <option value="">-- Escolhe um campo --</option>
            </select>

            <div style="margin-bottom: 15px;">
                <h4 style="margin-bottom: 10px; color: #1f2937;">Campos Mapeados</h4>
                <div id="mappedFieldsList" class="mapped-list"></div>
            </div>

            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <button class="btn btn-primary" onclick="saveFieldCoordinates()" title="Guardar Coordenadas">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="toggleEditMode()" id="editModeBtn" style="background: #8b5cf6;" title="Modo Editar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="deleteSelectedBox()" id="deleteBtn" style="background: #ef4444; color: white;" disabled title="Eliminar Caixa">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="previousField()" title="Campo Anterior">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="19" y1="12" x2="5" y2="12"></line>
                        <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="skipCurrentField()" title="Pular Campo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 4 15 12 5 20 5 4"></polygon>
                        <line x1="19" y1="5" x2="19" y2="19"></line>
                    </svg>
                </button>
                <button class="btn" onclick="clearAllFields()" style="background: #f4ad0f; color: white;" title="Limpar Todos os Campos">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const FIELDS_TO_MAP = [
            { id: 'dr_number', name: 'DR Nº (topo direita)', type: 'text' },
            { id: 'contract_number', name: 'Nº Contrato', type: 'text' },
            { id: 'contract_date', name: 'Data Contrato', type: 'text' },
            { id: 'customer_name', name: 'Nome Cliente', type: 'text' },
            { id: 'customer_email', name: 'Email Cliente', type: 'text' },
            { id: 'customer_phone', name: 'Telefone Cliente', type: 'text' },
            { id: 'customer_address', name: 'Morada Cliente', type: 'text' },
            { id: 'customer_city', name: 'Cidade Cliente', type: 'text' },
            { id: 'customer_postal', name: 'Código Postal Cliente', type: 'text' },
            { id: 'customer_country', name: 'País Cliente (auto)', type: 'text' },
            { id: 'vehicle_plate', name: 'Matrícula Veículo', type: 'text' },
            { id: 'vehicle_brand', name: 'Marca Veículo', type: 'text' },
            { id: 'vehicle_model', name: 'Modelo Veículo', type: 'text' },
            { id: 'vehicle_color', name: 'Cor Veículo', type: 'text' },
            { id: 'vehicle_km', name: 'KM Veículo', type: 'text' },
            { id: 'pickup_date', name: 'Data Recolha', type: 'text' },
            { id: 'pickup_time', name: 'Hora Recolha', type: 'text' },
            { id: 'pickup_location', name: 'Local Recolha', type: 'text' },
            { id: 'return_date', name: 'Data Devolução', type: 'text' },
            { id: 'return_time', name: 'Hora Devolução', type: 'text' },
            { id: 'return_location', name: 'Local Devolução', type: 'text' },
            { id: 'fuel_level_pickup', name: 'Nível Combustível (Recolha)', type: 'text' },
            { id: 'fuel_level_return', name: 'Nível Combustível (Devolução)', type: 'text' },
            { id: 'damage_description_line_1', name: 'Descrição Danos - Linha 1', type: 'text' },
            { id: 'damage_description_line_2', name: 'Descrição Danos - Linha 2', type: 'text' },
            { id: 'damage_description_line_3', name: 'Descrição Danos - Linha 3', type: 'text' },
            { id: 'damage_description_line_4', name: 'Descrição Danos - Linha 4', type: 'text' },
            { id: 'damage_description_line_5', name: 'Descrição Danos - Linha 5', type: 'text' },
            { id: 'damage_description_line_6', name: 'Descrição Danos - Linha 6', type: 'text' },
            { id: 'damage_description_line_7', name: 'Descrição Danos - Linha 7', type: 'text' },
            { id: 'damage_description_line_8', name: 'Descrição Danos - Linha 8', type: 'text' },
            { id: 'damage_description_line_9', name: 'Descrição Danos - Linha 9', type: 'text' },
            { id: 'damage_description_line_10', name: 'Descrição Danos - Linha 10', type: 'text' },
            { id: 'damage_description_line_11', name: 'Descrição Danos - Linha 11', type: 'text' },
            { id: 'damage_description_line_12', name: 'Descrição Danos - Linha 12', type: 'text' },
            { id: 'damage_description_line_13', name: 'Descrição Danos - Linha 13', type: 'text' },
            { id: 'damage_description_line_14', name: 'Descrição Danos - Linha 14', type: 'text' },
            { id: 'damage_description_line_15', name: 'Descrição Danos - Linha 15', type: 'text' },
            { id: 'repair_line_1', name: 'Reparação - Linha 1 (Detalhes/Qtd/Horas/Preço/Total)', type: 'table' },
            { id: 'repair_line_2', name: 'Reparação - Linha 2', type: 'table' },
            { id: 'repair_line_3', name: 'Reparação - Linha 3', type: 'table' },
            { id: 'repair_line_4', name: 'Reparação - Linha 4', type: 'table' },
            { id: 'repair_line_5', name: 'Reparação - Linha 5', type: 'table' },
            { id: 'repair_line_6', name: 'Reparação - Linha 6', type: 'table' },
            { id: 'repair_line_7', name: 'Reparação - Linha 7', type: 'table' },
            { id: 'repair_line_8', name: 'Reparação - Linha 8', type: 'table' },
            { id: 'repair_line_9', name: 'Reparação - Linha 9', type: 'table' },
            { id: 'repair_line_10', name: 'Reparação - Linha 10', type: 'table' },
            { id: 'total_repair_cost', name: 'Custo Total Reparação', type: 'text' },
            { id: 'vehicle_diagram', name: 'Diagrama do Veículo', type: 'diagram' },
            { id: 'damage_photo_1', name: 'Foto 1', type: 'image' },
            { id: 'damage_photo_2', name: 'Foto 2', type: 'image' },
            { id: 'damage_photo_3', name: 'Foto 3', type: 'image' },
            { id: 'damage_photo_4', name: 'Foto 4', type: 'image' },
            { id: 'damage_photo_5', name: 'Foto 5', type: 'image' },
            { id: 'damage_photo_6', name: 'Foto 6', type: 'image' },
            { id: 'damage_photo_7', name: 'Foto 7', type: 'image' },
            { id: 'damage_photo_8', name: 'Foto 8', type: 'image' },
            { id: 'damage_photo_9', name: 'Foto 9', type: 'image' },
            { id: 'inspector_name', name: 'Nome Inspetor', type: 'text' },
            { id: 'inspector_signature', name: 'Assinatura Inspetor', type: 'text' },
            { id: 'customer_signature', name: 'Assinatura Cliente', type: 'text' },
            { id: 'inspection_date', name: 'Data Inspeção', type: 'text' }
        ];

        let currentFieldIndex = 0;
        let fieldCoordinates = {};
        let canvas, ctx, scale, currentPage = 1, pdfDoc, pdfImageData;
        let isDrawing = false, startX, startY;
        let isDragging = false, draggedField = null, dragOffsetX = 0, dragOffsetY = 0;
        let isEditMode = false, selectedField = null;
        let isResizing = false, resizeHandle = null, resizeStartX = 0, resizeStartY = 0;

        async function loadPDFMapper() {
            canvas = document.getElementById('pdfCanvas');
            ctx = canvas.getContext('2d');
            
            const response = await fetch('/static/damage_report_with_grid.pdf');
            const arrayBuffer = await response.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            await renderPage(currentPage);
            
            canvas.onmousedown = onCanvasClick;
            canvas.onmousemove = onCanvasMouseMove;
            canvas.onmouseup = onCanvasMouseUp;
            
            populateFieldSelector();
            await loadExistingCoordinates();
        }

        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2 });
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            scale = viewport.scale;
            
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            pdfImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            redrawMappedBoxes();
            document.getElementById('canvasInfo').textContent = `Arrasta para criar caixas • Escala: ${scale}`;
        }

        function onCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Se em modo edição, verificar clique em handles primeiro
            if (isEditMode && selectedField) {
                const coords = fieldCoordinates[selectedField];
                if (coords && coords.page === currentPage) {
                    const handle = getHandleAtPosition(mouseX, mouseY, coords);
                    if (handle) {
                        isResizing = true;
                        resizeHandle = handle;
                        resizeStartX = mouseX;
                        resizeStartY = mouseY;
                        return;
                    }
                }
            }
            
            // Verificar se clicou numa caixa existente
            for (const [fieldId, coords] of Object.entries(fieldCoordinates)) {
                if (coords.page === currentPage) {
                    const boxX = coords.x * scale;
                    const boxY = coords.y * scale;
                    const boxW = coords.width * scale;
                    const boxH = coords.height * scale;
                    
                    if (mouseX >= boxX && mouseX <= boxX + boxW && 
                        mouseY >= boxY && mouseY <= boxY + boxH) {
                        
                        if (isEditMode) {
                            // Modo edição - selecionar caixa
                            selectedField = fieldId;
                            document.getElementById('deleteBtn').disabled = false;
                            redrawCanvas();
                        } else {
                            // Modo normal - arrastar caixa
                            isDragging = true;
                            draggedField = fieldId;
                            dragOffsetX = mouseX - boxX;
                            dragOffsetY = mouseY - boxY;
                            canvas.style.cursor = 'move';
                        }
                        return;
                    }
                }
            }
            
            // Não clicou em nenhuma caixa
            if (isEditMode) {
                // Desselecionar
                selectedField = null;
                document.getElementById('deleteBtn').disabled = true;
                redrawCanvas();
            } else {
                // Modo desenhar nova caixa
                startX = mouseX;
                startY = mouseY;
                isDrawing = true;
            }
        }

        function onCanvasMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (isResizing && selectedField) {
                // Redimensionar caixa
                const coords = fieldCoordinates[selectedField];
                const deltaX = mouseX - resizeStartX;
                const deltaY = mouseY - resizeStartY;
                
                const x = coords.x * scale;
                const y = coords.y * scale;
                const w = coords.width * scale;
                const h = coords.height * scale;
                
                // Aplicar redimensionamento baseado no handle
                if (resizeHandle.includes('l')) { // left
                    coords.x = (x + deltaX) / scale;
                    coords.width = (w - deltaX) / scale;
                }
                if (resizeHandle.includes('r')) { // right
                    coords.width = (w + deltaX) / scale;
                }
                if (resizeHandle.includes('t')) { // top
                    coords.y = (y + deltaY) / scale;
                    coords.height = (h - deltaY) / scale;
                }
                if (resizeHandle.includes('b')) { // bottom
                    coords.height = (h + deltaY) / scale;
                }
                
                resizeStartX = mouseX;
                resizeStartY = mouseY;
                redrawCanvas();
            } else if (isDragging && draggedField) {
                // Arrastar caixa existente
                const coords = fieldCoordinates[draggedField];
                coords.x = (mouseX - dragOffsetX) / scale;
                coords.y = (mouseY - dragOffsetY) / scale;
                
                ctx.putImageData(pdfImageData, 0, 0);
                redrawMappedBoxes();
            } else if (isDrawing) {
                // Desenhar nova caixa
                ctx.putImageData(pdfImageData, 0, 0);
                redrawMappedBoxes();
                
                ctx.strokeStyle = '#009cb6';
                ctx.lineWidth = 3;
                ctx.strokeRect(startX, startY, mouseX - startX, mouseY - startY);
            }
        }

        function onCanvasMouseUp(e) {
            if (isResizing) {
                // Terminar redimensionamento
                isResizing = false;
                resizeHandle = null;
                return;
            }
            
            if (isDragging) {
                // Terminar arrastar
                isDragging = false;
                draggedField = null;
                canvas.style.cursor = 'crosshair';
                return;
            }
            
            if (!isDrawing) return;
            isDrawing = false;
            
            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const endY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const field = FIELDS_TO_MAP[currentFieldIndex];
            if (!field) return;
            
            // Get initial box coordinates
            let boxX = Math.min(startX, endX) / scale;
            let boxY = Math.min(startY, endY) / scale;
            let boxW = Math.abs(endX - startX) / scale;
            let boxH = Math.abs(endY - startY) / scale;
            
            // Special auto-detection for vehicle diagram
            if (field.type === 'diagram') {
                const diagramBox = autoDetectVehicleDiagram();
                if (diagramBox) {
                    console.log('Vehicle diagram auto-detected:', diagramBox);
                    boxX = diagramBox.x;
                    boxY = diagramBox.y;
                    boxW = diagramBox.width;
                    boxH = diagramBox.height;
                    showCustomNotification('Diagrama do veículo detetado automaticamente!', 'success');
                } else {
                    // Try to detect white boxes/lines in the PDF
                    const detectedBox = detectWhiteBoxInArea(boxX, boxY, boxW, boxH);
                    if (detectedBox) {
                        console.log('White box detected, adjusting coordinates...');
                        boxX = detectedBox.x;
                        boxY = detectedBox.y;
                        boxW = detectedBox.width;
                        boxH = detectedBox.height;
                    }
                }
            } else {
                // Try to detect white boxes/lines in the PDF
                const detectedBox = detectWhiteBoxInArea(boxX, boxY, boxW, boxH);
                if (detectedBox) {
                    console.log('White box detected, adjusting coordinates...');
                    boxX = detectedBox.x;
                    boxY = detectedBox.y;
                    boxW = detectedBox.width;
                    boxH = detectedBox.height;
                }
            }
            
            fieldCoordinates[field.id] = {
                page: currentPage,
                x: boxX,
                y: boxY,
                width: boxW,
                height: boxH
            };
            
            updateMappedList();
            currentFieldIndex++;
            updateCurrentField();
            redrawMappedBoxes();
        }

        function autoDetectVehicleDiagram() {
            // Auto-detect vehicle diagram by looking for a large rectangular area
            // with car outline (typically in cyan/blue color on white background)
            try {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Look for cyan/blue lines (typical car diagram color)
                // RGB values for cyan: around (0, 174, 239) or similar blue tones
                let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
                let foundDiagram = false;
                
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // Detect cyan/blue lines (car outline color)
                        // Typical cyan: low red, medium-high green, high blue
                        if (r < 100 && g > 100 && b > 150 && b > r && b > g) {
                            foundDiagram = true;
                            if (x < minX) minX = x;
                            if (x > maxX) maxX = x;
                            if (y < minY) minY = y;
                            if (y > maxY) maxY = y;
                        }
                    }
                }
                
                // If found diagram with reasonable size (at least 200x150 pixels)
                if (foundDiagram && (maxX - minX) > 200 && (maxY - minY) > 150) {
                    // Add some padding
                    const padding = 20;
                    return {
                        x: Math.max(0, (minX - padding)) / scale,
                        y: Math.max(0, (minY - padding)) / scale,
                        width: Math.min(canvas.width, (maxX - minX + padding * 2)) / scale,
                        height: Math.min(canvas.height, (maxY - minY + padding * 2)) / scale
                    };
                }
            } catch (error) {
                console.error('[MAPPER] Error auto-detecting diagram:', error);
            }
            
            return null;
        }
        
        function detectWhiteBoxInArea(x, y, width, height) {
            // Convert to canvas coordinates
            const canvasX = Math.floor(x * scale);
            const canvasY = Math.floor(y * scale);
            const canvasW = Math.floor(width * scale);
            const canvasH = Math.floor(height * scale);
            
            // Get image data for the selected area
            const imageData = ctx.getImageData(canvasX, canvasY, canvasW, canvasH);
            const data = imageData.data;
            
            // Find edges of white area (threshold: RGB > 240)
            let minX = canvasW, minY = canvasH, maxX = 0, maxY = 0;
            let foundWhite = false;
            
            for (let py = 0; py < canvasH; py++) {
                for (let px = 0; px < canvasW; px++) {
                    const idx = (py * canvasW + px) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Check if pixel is white (or very light)
                    if (r > 240 && g > 240 && b > 240) {
                        foundWhite = true;
                        if (px < minX) minX = px;
                        if (px > maxX) maxX = px;
                        if (py < minY) minY = py;
                        if (py > maxY) maxY = py;
                    }
                }
            }
            
            // If found white area larger than 50% of selection, use it
            if (foundWhite && (maxX - minX) * (maxY - minY) > (canvasW * canvasH * 0.5)) {
                return {
                    x: (canvasX + minX) / scale,
                    y: (canvasY + minY) / scale,
                    width: (maxX - minX) / scale,
                    height: (maxY - minY) / scale
                };
            }
            
            return null;
        }

        function redrawMappedBoxes() {
            for (const [fieldId, coords] of Object.entries(fieldCoordinates)) {
                if (coords.page === currentPage) {
                    const isSelected = selectedField === fieldId;
                    
                    // Desenhar caixa
                    ctx.strokeStyle = isSelected ? '#f59e0b' : '#10b981';
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.strokeRect(
                        coords.x * scale,
                        coords.y * scale,
                        coords.width * scale,
                        coords.height * scale
                    );
                    
                    // Se selecionada e em modo edição, desenhar handles
                    if (isSelected && isEditMode) {
                        const handleSize = 8;
                        const x = coords.x * scale;
                        const y = coords.y * scale;
                        const w = coords.width * scale;
                        const h = coords.height * scale;
                        
                        ctx.fillStyle = '#f59e0b';
                        
                        // 4 cantos
                        ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize); // top-left
                        ctx.fillRect(x + w - handleSize/2, y - handleSize/2, handleSize, handleSize); // top-right
                        ctx.fillRect(x - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom-left
                        ctx.fillRect(x + w - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom-right
                        
                        // 4 lados
                        ctx.fillRect(x + w/2 - handleSize/2, y - handleSize/2, handleSize, handleSize); // top
                        ctx.fillRect(x + w/2 - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom
                        ctx.fillRect(x - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // left
                        ctx.fillRect(x + w - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // right
                    }
                }
            }
        }

        function populateFieldSelector() {
            const selector = document.getElementById('fieldSelector');
            FIELDS_TO_MAP.forEach((field, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = field.name;
                selector.appendChild(option);
            });
        }

        function selectFieldManually() {
            const selector = document.getElementById('fieldSelector');
            currentFieldIndex = parseInt(selector.value) || 0;
            updateCurrentField();
        }

        function updateCurrentField() {
            const field = FIELDS_TO_MAP[currentFieldIndex];
            if (field) {
                document.getElementById('currentFieldName').textContent = field.name;
                document.getElementById('fieldSelector').value = currentFieldIndex;
            }
            updateProgress();
        }

        function updateProgress() {
            const mapped = Object.keys(fieldCoordinates).length;
            document.getElementById('fieldProgress').textContent = `${mapped} / ${FIELDS_TO_MAP.length} campos`;
        }

        function updateMappedList() {
            const list = document.getElementById('mappedFieldsList');
            list.innerHTML = '';
            Object.keys(fieldCoordinates).forEach(fieldId => {
                const field = FIELDS_TO_MAP.find(f => f.id === fieldId);
                if (field) {
                    const item = document.createElement('div');
                    item.className = 'mapped-item';
                    item.innerHTML = `<span>✓ ${field.name}</span>`;
                    list.appendChild(item);
                }
            });
        }

        async function saveFieldCoordinates(e) {
            if (e) e.preventDefault();
            try {
                console.log('[MAPPER] Saving coordinates:', fieldCoordinates);
                const response = await fetch('/api/damage-reports/save-coordinates', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fieldCoordinates)
                });
                const result = await response.json();
                console.log('[MAPPER] Save result:', result);
                if (result.ok) {
                    showCustomNotification('Coordenadas guardadas com sucesso!', 'success');
                    window.parent.postMessage({ type: 'coordinatesSaved' }, '*');
                } else {
                    showCustomNotification('Erro ao guardar: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('[MAPPER] Save error:', error);
                showCustomNotification('Erro ao guardar coordenadas', 'error');
            }
        }

        function skipCurrentField(e) {
            if (e) e.preventDefault();
            currentFieldIndex++;
            if (currentFieldIndex >= FIELDS_TO_MAP.length) {
                currentFieldIndex = FIELDS_TO_MAP.length - 1;
                showCustomNotification('Já está no último campo', 'info');
            }
            updateCurrentField();
        }

        function previousField(e) {
            if (e) e.preventDefault();
            if (currentFieldIndex > 0) {
                currentFieldIndex--;
                updateCurrentField();
            } else {
                showCustomNotification('Já está no primeiro campo', 'info');
            }
        }

        async function loadExistingCoordinates() {
            try {
                console.log('[MAPPER] Loading existing coordinates...');
                const response = await fetch('/api/damage-reports/get-coordinates');
                const data = await response.json();
                console.log('[MAPPER] Load response:', data);
                if (data.ok && data.coordinates) {
                    fieldCoordinates = data.coordinates;
                    console.log('[MAPPER] Loaded coordinates:', fieldCoordinates);
                    updateMappedList();
                    updateProgress();
                    redrawMappedBoxes();
                } else {
                    console.log('[MAPPER] No existing coordinates found');
                }
            } catch (error) {
                console.error('[MAPPER] Error loading coordinates:', error);
            }
        }

        function nextPage() {
            if (currentPage < pdfDoc.numPages) {
                currentPage++;
                renderPage(currentPage);
                document.getElementById('pageInfo').textContent = `Página ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                renderPage(currentPage);
                document.getElementById('pageInfo').textContent = `Página ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        function getHandleAtPosition(mouseX, mouseY, coords) {
            const handleSize = 8;
            const x = coords.x * scale;
            const y = coords.y * scale;
            const w = coords.width * scale;
            const h = coords.height * scale;
            
            const handles = {
                'tl': {x: x, y: y},
                'tr': {x: x + w, y: y},
                'bl': {x: x, y: y + h},
                'br': {x: x + w, y: y + h},
                't': {x: x + w/2, y: y},
                'b': {x: x + w/2, y: y + h},
                'l': {x: x, y: y + h/2},
                'r': {x: x + w, y: y + h/2}
            };
            
            for (const [name, pos] of Object.entries(handles)) {
                if (Math.abs(mouseX - pos.x) <= handleSize && Math.abs(mouseY - pos.y) <= handleSize) {
                    return name;
                }
            }
            return null;
        }

        function toggleEditMode(e) {
            if (e) e.preventDefault();
            isEditMode = !isEditMode;
            const btn = document.getElementById('editModeBtn');
            btn.style.background = isEditMode ? '#10b981' : '#8b5cf6';
            btn.title = isEditMode ? 'Modo Editar: ON' : 'Modo Editar: OFF';
            
            if (!isEditMode) {
                selectedField = null;
                document.getElementById('deleteBtn').disabled = true;
            }
            redrawCanvas();
            console.log('[MAPPER] Edit mode:', isEditMode ? 'ON' : 'OFF');
        }

        // Proteção contra múltiplas chamadas
        let clearAllFieldsInProgress = false;
        
        function clearAllFields(e) {
            if (e) e.preventDefault();
            
            // Proteção: Se já está em progresso, ignora
            if (clearAllFieldsInProgress) {
                console.log('[MAPPER] clearAllFields already in progress, ignoring duplicate call');
                return;
            }
            
            // Verifica se há campos para limpar
            const mappedCount = Object.keys(fieldCoordinates).length;
            if (mappedCount === 0) {
                showCustomNotification('Não há campos mapeados para limpar', 'info');
                console.log('[MAPPER] No fields to clear');
                return;
            }
            
            // Ativa proteção
            clearAllFieldsInProgress = true;
            console.log('[MAPPER] clearAllFields called - showing confirmation modal');
            
            showCustomConfirmModal(
                'Limpar Todos os Campos?',
                `Tem a certeza que deseja limpar TODOS os ${mappedCount} campos mapeados? Esta ação não pode ser desfeita.`,
                () => {
                    // CONFIRMADO - Limpar campos
                    fieldCoordinates = {};
                    selectedField = null;
                    currentFieldIndex = 0;
                    document.getElementById('deleteBtn').disabled = true;
                    updateMappedList();
                    updateProgress();
                    updateCurrentField();
                    redrawCanvas();
                    showNotification(`${mappedCount} campos foram limpos`, 'warning');
                    console.log(`[MAPPER] Cleared all fields (${mappedCount} removed)`);
                    
                    // Libera proteção após 2 segundos
                    setTimeout(() => {
                        clearAllFieldsInProgress = false;
                    }, 2000);
                },
                () => {
                    // CANCELADO
                    console.log('[MAPPER] Clear all fields cancelled by user');
                    // Libera proteção imediatamente
                    clearAllFieldsInProgress = false;
                }
            );
        }

        function showNotification(message, type) {
            showCustomNotification(message, type);
        }
        
        function showCustomNotification(message, type = 'info') {
            const colors = {
                'success': '#10b981',
                'error': '#ef4444',
                'warning': '#f59e0b',
                'info': '#009cb6'
            };
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: white;
                color: #1f2937;
                padding: 16px 20px;
                border-left: 4px solid ${colors[type] || colors.info};
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 100000;
                max-width: 400px;
                font-size: 14px;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function deleteSelectedBox(e) {
            if (e) e.preventDefault();
            if (selectedField && fieldCoordinates[selectedField]) {
                const fieldName = FIELDS_TO_MAP.find(f => f.id === selectedField)?.name;
                
                showCustomConfirmModal(
                    'Eliminar Campo?',
                    `Tem a certeza que deseja eliminar o campo "${fieldName}"?`,
                    () => {
                        delete fieldCoordinates[selectedField];
                        selectedField = null;
                        document.getElementById('deleteBtn').disabled = true;
                        updateMappedList();
                        updateProgress();
                        redrawCanvas();
                        showCustomNotification(`Campo "${fieldName}" eliminado`, 'info');
                        console.log(`[MAPPER] Deleted field: ${fieldName}`);
                    }
                );
            }
        }
        
        function showCustomConfirmModal(title, message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 999999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 24px;
                border-radius: 12px;
                max-width: 400px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: #1f2937; font-size: 18px;">${title}</h3>
                <p style="margin: 0 0 24px 0; color: #6b7280; font-size: 14px; line-height: 1.5;">${message}</p>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="cancelBtn" style="padding: 10px 20px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Cancelar</button>
                    <button id="confirmBtn" style="padding: 10px 20px; border: none; background: #ef4444; color: white; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Confirmar</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const cancelBtn = content.querySelector('#cancelBtn');
            const confirmBtn = content.querySelector('#confirmBtn');
            
            cancelBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                modal.remove();
                if (onCancel) onCancel();
            };
            
            confirmBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                modal.remove();
                if (onConfirm) onConfirm();
            };
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    e.preventDefault();
                    modal.remove();
                }
            };
        }

        function redrawCanvas() {
            ctx.putImageData(pdfImageData, 0, 0);
            redrawMappedBoxes();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadPDFMapper();
            updateCurrentField();
        });
    </script>
</body>
</html>
