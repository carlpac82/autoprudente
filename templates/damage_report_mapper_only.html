<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapeador de Campos PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f9fafb;
            padding: 20px;
        }
        .mapper-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            max-width: 100%;
        }
        .pdf-viewer {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
        }
        .controls {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
        }
        canvas {
            width: 100%;
            cursor: crosshair;
            border: 1px solid #d1d5db;
        }
        .btn {
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            min-height: 44px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        .btn-primary {
            background: #009cb6;
            color: white;
        }
        .btn-primary:hover {
            background: #008299;
        }
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        .field-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .current-field {
            background: #f0f9fb;
            border: 2px solid #009cb6;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
        }
        .current-field h3 {
            color: #009cb6;
            font-size: 16px;
            margin-bottom: 5px;
        }
        .mapped-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 13px;
        }
        .mapped-item {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .page-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="mapper-container">
        <!-- PDF Viewer -->
        <div class="pdf-viewer">
            <div class="page-controls">
                <button class="btn btn-secondary" onclick="previousPage()">← Anterior</button>
                <span id="pageInfo">Página 1 / 2</span>
                <button class="btn btn-secondary" onclick="nextPage()">Seguinte →</button>
            </div>
            <canvas id="pdfCanvas"></canvas>
            <div style="text-align: center; margin-top: 10px; color: #6b7280; font-size: 12px;">
                <span id="canvasInfo">Carregando PDF...</span>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="current-field">
                <h3>Campo Atual</h3>
                <div id="currentFieldName" style="font-size: 18px; font-weight: bold; color: #1f2937;">
                    Escolhe um campo
                </div>
                <div style="margin-top: 10px;">
                    <span id="fieldProgress">0 / 38 campos</span>
                </div>
            </div>

            <select id="fieldSelector" class="field-selector" onchange="selectFieldManually()">
                <option value="">-- Escolhe um campo --</option>
            </select>

            <div style="margin-bottom: 15px;">
                <h4 style="margin-bottom: 10px; color: #1f2937;">Campos Mapeados</h4>
                <div id="mappedFieldsList" class="mapped-list"></div>
            </div>

            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <button class="btn btn-primary" onclick="saveFieldCoordinates()" title="Guardar Coordenadas">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="toggleEditMode()" id="editModeBtn" style="background: #8b5cf6;" title="Modo Editar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="deleteSelectedBox()" id="deleteBtn" style="background: #ef4444; color: white;" disabled title="Eliminar Caixa">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="previousField()" title="Campo Anterior">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="19" y1="12" x2="5" y2="12"></line>
                        <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                </button>
                <button class="btn btn-secondary" onclick="skipCurrentField()" title="Pular Campo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 4 15 12 5 20 5 4"></polygon>
                        <line x1="19" y1="5" x2="19" y2="19"></line>
                    </svg>
                </button>
                <button class="btn" onclick="clearAllFields()" style="background: #f4ad0f; color: white;" title="Limpar Todos os Campos">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const FIELDS_TO_MAP = [
            { id: 'dr_number', name: 'DR Nº (topo direita)', type: 'text' },
            { id: 'contract_number', name: 'Nº Contrato', type: 'text' },
            { id: 'contract_date', name: 'Data Contrato', type: 'text' },
            { id: 'customer_name', name: 'Nome Cliente', type: 'text' },
            { id: 'customer_email', name: 'Email Cliente', type: 'text' },
            { id: 'customer_phone', name: 'Telefone Cliente', type: 'text' },
            { id: 'customer_address', name: 'Morada Cliente', type: 'text' },
            { id: 'customer_city', name: 'Cidade Cliente', type: 'text' },
            { id: 'customer_postal', name: 'Código Postal Cliente', type: 'text' },
            { id: 'customer_country', name: 'País Cliente (auto)', type: 'text' },
            { id: 'vehicle_plate', name: 'Matrícula Veículo', type: 'text' },
            { id: 'vehicle_brand', name: 'Marca Veículo', type: 'text' },
            { id: 'vehicle_model', name: 'Modelo Veículo', type: 'text' },
            { id: 'vehicle_color', name: 'Cor Veículo', type: 'text' },
            { id: 'vehicle_km', name: 'KM Veículo', type: 'text' },
            { id: 'pickup_date', name: 'Data Recolha', type: 'text' },
            { id: 'pickup_time', name: 'Hora Recolha', type: 'text' },
            { id: 'pickup_location', name: 'Local Recolha', type: 'text' },
            { id: 'return_date', name: 'Data Devolução', type: 'text' },
            { id: 'return_time', name: 'Hora Devolução', type: 'text' },
            { id: 'return_location', name: 'Local Devolução', type: 'text' },
            { id: 'fuel_level_pickup', name: 'Nível Combustível (Recolha)', type: 'text' },
            { id: 'fuel_level_return', name: 'Nível Combustível (Devolução)', type: 'text' },
            { id: 'damage_description', name: 'Descrição Danos', type: 'textarea' },
            { id: 'damage_table', name: 'Tabela de Danos', type: 'table' },
            { id: 'repair_items_table', name: 'Tabela Itens Reparação', type: 'table' },
            { id: 'total_repair_cost', name: 'Custo Total Reparação', type: 'text' },
            { id: 'vehicle_diagram', name: 'Diagrama do Veículo', type: 'diagram' },
            { id: 'damage_photo_1', name: 'Foto 1', type: 'image' },
            { id: 'damage_photo_2', name: 'Foto 2', type: 'image' },
            { id: 'damage_photo_3', name: 'Foto 3', type: 'image' },
            { id: 'damage_photo_4', name: 'Foto 4', type: 'image' },
            { id: 'damage_photo_5', name: 'Foto 5', type: 'image' },
            { id: 'damage_photo_6', name: 'Foto 6', type: 'image' },
            { id: 'damage_photo_7', name: 'Foto 7', type: 'image' },
            { id: 'damage_photo_8', name: 'Foto 8', type: 'image' },
            { id: 'damage_photo_9', name: 'Foto 9', type: 'image' },
            { id: 'inspector_name', name: 'Nome Inspetor', type: 'text' },
            { id: 'inspector_signature', name: 'Assinatura Inspetor', type: 'text' },
            { id: 'customer_signature', name: 'Assinatura Cliente', type: 'text' },
            { id: 'inspection_date', name: 'Data Inspeção', type: 'text' }
        ];

        let currentFieldIndex = 0;
        let fieldCoordinates = {};
        let canvas, ctx, scale, currentPage = 1, pdfDoc, pdfImageData;
        let isDrawing = false, startX, startY;
        let isDragging = false, draggedField = null, dragOffsetX = 0, dragOffsetY = 0;
        let isEditMode = false, selectedField = null;
        let isResizing = false, resizeHandle = null, resizeStartX = 0, resizeStartY = 0;

        async function loadPDFMapper() {
            canvas = document.getElementById('pdfCanvas');
            ctx = canvas.getContext('2d');
            
            const response = await fetch('/static/damage_report_with_grid.pdf');
            const arrayBuffer = await response.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            await renderPage(currentPage);
            
            canvas.onmousedown = onCanvasClick;
            canvas.onmousemove = onCanvasMouseMove;
            canvas.onmouseup = onCanvasMouseUp;
            
            populateFieldSelector();
            await loadExistingCoordinates();
        }

        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2 });
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            scale = viewport.scale;
            
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            pdfImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            redrawMappedBoxes();
            document.getElementById('canvasInfo').textContent = `Arrasta para criar caixas • Escala: ${scale}`;
        }

        function onCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Se em modo edição, verificar clique em handles primeiro
            if (isEditMode && selectedField) {
                const coords = fieldCoordinates[selectedField];
                if (coords && coords.page === currentPage) {
                    const handle = getHandleAtPosition(mouseX, mouseY, coords);
                    if (handle) {
                        isResizing = true;
                        resizeHandle = handle;
                        resizeStartX = mouseX;
                        resizeStartY = mouseY;
                        return;
                    }
                }
            }
            
            // Verificar se clicou numa caixa existente
            for (const [fieldId, coords] of Object.entries(fieldCoordinates)) {
                if (coords.page === currentPage) {
                    const boxX = coords.x * scale;
                    const boxY = coords.y * scale;
                    const boxW = coords.width * scale;
                    const boxH = coords.height * scale;
                    
                    if (mouseX >= boxX && mouseX <= boxX + boxW && 
                        mouseY >= boxY && mouseY <= boxY + boxH) {
                        
                        if (isEditMode) {
                            // Modo edição - selecionar caixa
                            selectedField = fieldId;
                            document.getElementById('deleteBtn').disabled = false;
                            redrawCanvas();
                        } else {
                            // Modo normal - arrastar caixa
                            isDragging = true;
                            draggedField = fieldId;
                            dragOffsetX = mouseX - boxX;
                            dragOffsetY = mouseY - boxY;
                            canvas.style.cursor = 'move';
                        }
                        return;
                    }
                }
            }
            
            // Não clicou em nenhuma caixa
            if (isEditMode) {
                // Desselecionar
                selectedField = null;
                document.getElementById('deleteBtn').disabled = true;
                redrawCanvas();
            } else {
                // Modo desenhar nova caixa
                startX = mouseX;
                startY = mouseY;
                isDrawing = true;
            }
        }

        function onCanvasMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (isResizing && selectedField) {
                // Redimensionar caixa
                const coords = fieldCoordinates[selectedField];
                const deltaX = mouseX - resizeStartX;
                const deltaY = mouseY - resizeStartY;
                
                const x = coords.x * scale;
                const y = coords.y * scale;
                const w = coords.width * scale;
                const h = coords.height * scale;
                
                // Aplicar redimensionamento baseado no handle
                if (resizeHandle.includes('l')) { // left
                    coords.x = (x + deltaX) / scale;
                    coords.width = (w - deltaX) / scale;
                }
                if (resizeHandle.includes('r')) { // right
                    coords.width = (w + deltaX) / scale;
                }
                if (resizeHandle.includes('t')) { // top
                    coords.y = (y + deltaY) / scale;
                    coords.height = (h - deltaY) / scale;
                }
                if (resizeHandle.includes('b')) { // bottom
                    coords.height = (h + deltaY) / scale;
                }
                
                resizeStartX = mouseX;
                resizeStartY = mouseY;
                redrawCanvas();
            } else if (isDragging && draggedField) {
                // Arrastar caixa existente
                const coords = fieldCoordinates[draggedField];
                coords.x = (mouseX - dragOffsetX) / scale;
                coords.y = (mouseY - dragOffsetY) / scale;
                
                ctx.putImageData(pdfImageData, 0, 0);
                redrawMappedBoxes();
            } else if (isDrawing) {
                // Desenhar nova caixa
                ctx.putImageData(pdfImageData, 0, 0);
                redrawMappedBoxes();
                
                ctx.strokeStyle = '#009cb6';
                ctx.lineWidth = 3;
                ctx.strokeRect(startX, startY, mouseX - startX, mouseY - startY);
            }
        }

        function onCanvasMouseUp(e) {
            if (isResizing) {
                // Terminar redimensionamento
                isResizing = false;
                resizeHandle = null;
                return;
            }
            
            if (isDragging) {
                // Terminar arrastar
                isDragging = false;
                draggedField = null;
                canvas.style.cursor = 'crosshair';
                return;
            }
            
            if (!isDrawing) return;
            isDrawing = false;
            
            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const endY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const field = FIELDS_TO_MAP[currentFieldIndex];
            if (!field) return;
            
            // Get initial box coordinates
            let boxX = Math.min(startX, endX) / scale;
            let boxY = Math.min(startY, endY) / scale;
            let boxW = Math.abs(endX - startX) / scale;
            let boxH = Math.abs(endY - startY) / scale;
            
            // Try to detect white boxes/lines in the PDF
            const detectedBox = detectWhiteBoxInArea(boxX, boxY, boxW, boxH);
            if (detectedBox) {
                console.log('White box detected, adjusting coordinates...');
                boxX = detectedBox.x;
                boxY = detectedBox.y;
                boxW = detectedBox.width;
                boxH = detectedBox.height;
            }
            
            fieldCoordinates[field.id] = {
                page: currentPage,
                x: boxX,
                y: boxY,
                width: boxW,
                height: boxH
            };
            
            updateMappedList();
            currentFieldIndex++;
            updateCurrentField();
            redrawMappedBoxes();
        }

        function detectWhiteBoxInArea(x, y, width, height) {
            // Convert to canvas coordinates
            const canvasX = Math.floor(x * scale);
            const canvasY = Math.floor(y * scale);
            const canvasW = Math.floor(width * scale);
            const canvasH = Math.floor(height * scale);
            
            // Get image data for the selected area
            const imageData = ctx.getImageData(canvasX, canvasY, canvasW, canvasH);
            const data = imageData.data;
            
            // Find edges of white area (threshold: RGB > 240)
            let minX = canvasW, minY = canvasH, maxX = 0, maxY = 0;
            let foundWhite = false;
            
            for (let py = 0; py < canvasH; py++) {
                for (let px = 0; px < canvasW; px++) {
                    const idx = (py * canvasW + px) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Check if pixel is white (or very light)
                    if (r > 240 && g > 240 && b > 240) {
                        foundWhite = true;
                        if (px < minX) minX = px;
                        if (px > maxX) maxX = px;
                        if (py < minY) minY = py;
                        if (py > maxY) maxY = py;
                    }
                }
            }
            
            // If found white area larger than 50% of selection, use it
            if (foundWhite && (maxX - minX) * (maxY - minY) > (canvasW * canvasH * 0.5)) {
                return {
                    x: (canvasX + minX) / scale,
                    y: (canvasY + minY) / scale,
                    width: (maxX - minX) / scale,
                    height: (maxY - minY) / scale
                };
            }
            
            return null;
        }

        function redrawMappedBoxes() {
            for (const [fieldId, coords] of Object.entries(fieldCoordinates)) {
                if (coords.page === currentPage) {
                    const isSelected = selectedField === fieldId;
                    
                    // Desenhar caixa
                    ctx.strokeStyle = isSelected ? '#f59e0b' : '#10b981';
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.strokeRect(
                        coords.x * scale,
                        coords.y * scale,
                        coords.width * scale,
                        coords.height * scale
                    );
                    
                    // Se selecionada e em modo edição, desenhar handles
                    if (isSelected && isEditMode) {
                        const handleSize = 8;
                        const x = coords.x * scale;
                        const y = coords.y * scale;
                        const w = coords.width * scale;
                        const h = coords.height * scale;
                        
                        ctx.fillStyle = '#f59e0b';
                        
                        // 4 cantos
                        ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize); // top-left
                        ctx.fillRect(x + w - handleSize/2, y - handleSize/2, handleSize, handleSize); // top-right
                        ctx.fillRect(x - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom-left
                        ctx.fillRect(x + w - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom-right
                        
                        // 4 lados
                        ctx.fillRect(x + w/2 - handleSize/2, y - handleSize/2, handleSize, handleSize); // top
                        ctx.fillRect(x + w/2 - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // bottom
                        ctx.fillRect(x - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // left
                        ctx.fillRect(x + w - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // right
                    }
                }
            }
        }

        function populateFieldSelector() {
            const selector = document.getElementById('fieldSelector');
            FIELDS_TO_MAP.forEach((field, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = field.name;
                selector.appendChild(option);
            });
        }

        function selectFieldManually() {
            const selector = document.getElementById('fieldSelector');
            currentFieldIndex = parseInt(selector.value) || 0;
            updateCurrentField();
        }

        function updateCurrentField() {
            const field = FIELDS_TO_MAP[currentFieldIndex];
            if (field) {
                document.getElementById('currentFieldName').textContent = field.name;
                document.getElementById('fieldSelector').value = currentFieldIndex;
            }
            updateProgress();
        }

        function updateProgress() {
            const mapped = Object.keys(fieldCoordinates).length;
            document.getElementById('fieldProgress').textContent = `${mapped} / ${FIELDS_TO_MAP.length} campos`;
        }

        function updateMappedList() {
            const list = document.getElementById('mappedFieldsList');
            list.innerHTML = '';
            Object.keys(fieldCoordinates).forEach(fieldId => {
                const field = FIELDS_TO_MAP.find(f => f.id === fieldId);
                if (field) {
                    const item = document.createElement('div');
                    item.className = 'mapped-item';
                    item.innerHTML = `<span>✓ ${field.name}</span>`;
                    list.appendChild(item);
                }
            });
        }

        async function saveFieldCoordinates() {
            try {
                const response = await fetch('/api/damage-reports/save-coordinates', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ coordinates: fieldCoordinates })
                });
                const result = await response.json();
                if (result.ok) {
                    alert('Coordenadas guardadas com sucesso!');
                    window.parent.postMessage({ type: 'coordinatesSaved' }, '*');
                } else {
                    alert('Erro ao guardar: ' + result.error);
                }
            } catch (error) {
                alert('Erro ao guardar coordenadas');
            }
        }

        function skipCurrentField() {
            currentFieldIndex++;
            updateCurrentField();
        }

        function previousField() {
            if (currentFieldIndex > 0) {
                currentFieldIndex--;
                updateCurrentField();
            }
        }

        async function loadExistingCoordinates() {
            try {
                const response = await fetch('/api/damage-reports/get-coordinates');
                const data = await response.json();
                if (data.ok && data.coordinates) {
                    fieldCoordinates = data.coordinates;
                    updateMappedList();
                    updateProgress();
                    redrawMappedBoxes();
                }
            } catch (error) {
                console.error('Error loading coordinates:', error);
            }
        }

        function nextPage() {
            if (currentPage < pdfDoc.numPages) {
                currentPage++;
                renderPage(currentPage);
                document.getElementById('pageInfo').textContent = `Página ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                renderPage(currentPage);
                document.getElementById('pageInfo').textContent = `Página ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        function getHandleAtPosition(mouseX, mouseY, coords) {
            const handleSize = 8;
            const x = coords.x * scale;
            const y = coords.y * scale;
            const w = coords.width * scale;
            const h = coords.height * scale;
            
            const handles = {
                'tl': {x: x, y: y},
                'tr': {x: x + w, y: y},
                'bl': {x: x, y: y + h},
                'br': {x: x + w, y: y + h},
                't': {x: x + w/2, y: y},
                'b': {x: x + w/2, y: y + h},
                'l': {x: x, y: y + h/2},
                'r': {x: x + w, y: y + h/2}
            };
            
            for (const [name, pos] of Object.entries(handles)) {
                if (Math.abs(mouseX - pos.x) <= handleSize && Math.abs(mouseY - pos.y) <= handleSize) {
                    return name;
                }
            }
            return null;
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            const btn = document.getElementById('editModeBtn');
            btn.style.background = isEditMode ? '#10b981' : '#8b5cf6';
            btn.title = isEditMode ? 'Modo Editar: ON' : 'Modo Editar: OFF';
            
            if (!isEditMode) {
                selectedField = null;
                document.getElementById('deleteBtn').disabled = true;
            }
            redrawCanvas();
        }

        function clearAllFields() {
            if (confirm('Tem a certeza que deseja limpar TODOS os campos mapeados? Esta ação não pode ser desfeita.')) {
                fieldCoordinates = {};
                selectedField = null;
                currentFieldIndex = 0;
                document.getElementById('deleteBtn').disabled = true;
                updateMappedList();
                updateProgress();
                updateCurrentField();
                redrawCanvas();
                showNotification('Todos os campos foram limpos', 'warning');
            }
        }

        function showNotification(message, type) {
            // Simple notification - can be enhanced later
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function deleteSelectedBox() {
            if (selectedField && fieldCoordinates[selectedField]) {
                if (confirm(`Eliminar campo "${FIELDS_TO_MAP.find(f => f.id === selectedField)?.name}"?`)) {
                    delete fieldCoordinates[selectedField];
                    selectedField = null;
                    document.getElementById('deleteBtn').disabled = true;
                    updateMappedList();
                    updateProgress();
                    redrawCanvas();
                }
            }
        }

        function redrawCanvas() {
            ctx.putImageData(pdfImageData, 0, 0);
            redrawMappedBoxes();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadPDFMapper();
            updateCurrentField();
        });
    </script>
</body>
</html>
